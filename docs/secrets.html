---

title: Secrets Revealed 

keywords: fastai
sidebar: home_sidebar

summary: "Summary"
description: "Summary"
nb_path: "08_secrets.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 08_secrets.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We take a peek under the hood and explain how Git performs its miracles. I will skimp over details. For in-depth descriptions refer to <a href="http://schacon.github.com/git/user-manual.html[the">http://schacon.github.com/git/user-manual.html[the</a> user manual].</p>
<h3 id="Invisibility">Invisibility<a class="anchor-link" href="#Invisibility"> </a></h3><p>How can Git be so unobtrusive? Aside from occasional commits and merges, you can work as if you were unaware that version control exists. That is, until you need it, and that's when you're glad Git was watching over you the whole time.</p>
<p>Other version control systems force you to constantly struggle with red tape and bureaucracy. Permissions of files may be read-only unless you explicitly tell a central server which files you intend to edit. The most basic commands may slow to a crawl as the number of users increases. Work grinds to a halt when the network or the central server goes down.</p>
<p>In contrast, Git simply keeps the history of your project in the <code>.git</code> directory in your working directory. This is your own copy of the history, so you can stay offline until you want to communicate with others. You have total control over the fate of your files because Git can easily recreate a saved state from <code>.git</code> at any time.</p>
<h3 id="Integrity">Integrity<a class="anchor-link" href="#Integrity"> </a></h3><p>Most people associate cryptography with keeping information secret, but another equally important goal is keeping information safe. Proper use of cryptographic hash functions can prevent accidental or malicious data corruption.</p>
<p>A SHA1 hash can be thought of as a unique 160-bit ID number for every string of bytes you'll encounter in your life. Actually more than that: every string of bytes that any human will ever use over many lifetimes.</p>
<p>As a SHA1 hash is itself a string of bytes, we can hash strings of bytes containing other hashes. This simple observation is surprisingly useful: look up 'hash chains'. We'll later see how Git uses it to efficiently guarantee data integrity.</p>
<p>Briefly, Git keeps your data in the <code>.git/objects</code> subdirectory, where instead of normal filenames, you'll find only IDs. By using IDs as filenames, as well as a few lockfiles and timestamping tricks, Git transforms any humble filesystem into an efficient and robust database.</p>
<h3 id="Intelligence">Intelligence<a class="anchor-link" href="#Intelligence"> </a></h3><p>How does Git know you renamed a file, even though you never mentioned the fact explicitly? Sure, you may have run <em>git mv</em>, but that is exactly the same as a <em>git rm</em> followed by a <em>git add</em>.</p>
<p>Git heuristically ferrets out renames and copies between successive versions. In fact, it can detect chunks of code being moved or copied around between files! Though it cannot cover all cases, it does a decent job, and this feature is always improving. If it fails to work for you, try options enabling more expensive copy detection, and consider upgrading.</p>
<h3 id="Indexing">Indexing<a class="anchor-link" href="#Indexing"> </a></h3><p>For every tracked file, Git records information such as its size, creation time and last modification time in a file known as the 'index'. To determine whether a file has changed, Git compares its current stats with those cached in the index. If they match, then Git can skip reading the file again.</p>
<p>Since stat calls are considerably faster than file reads, if you only edit a
few files, Git can update its state in almost no time.</p>
<p>We stated earlier that the index is a staging area. Why is a bunch of file
stats a staging area? Because the add command puts files into Git's database
and updates these stats, while the commit command, without options, creates a
commit based only on these stats and the files already in the database.</p>
<h3 id="Git's-Origins">Git's Origins<a class="anchor-link" href="#Git's-Origins"> </a></h3><p>This <a href="http://lkml.org/lkml/2005/4/6/121[Linux">http://lkml.org/lkml/2005/4/6/121[Linux</a> Kernel Mailing List post] describes the chain of events that led to Git. The entire thread is a fascinating archaeological site for Git historians.</p>
<h3 id="The-Object-Database">The Object Database<a class="anchor-link" href="#The-Object-Database"> </a></h3><p>Every version of your data is kept in the 'object database', which lives in the
subdirectory <code>.git/objects</code>; the other residents of <code>.git/</code> hold lesser data:
the index, branch names, tags, configuration options, logs, the current
location of the head commit, and so on. The object database is elementary yet
elegant, and the source of Git's power.</p>
<p>Each file within <code>.git/objects</code> is an 'object'. There are 3 kinds of objects
that concern us: 'blob' objects, 'tree' objects, and 'commit' objects.</p>
<h3 id="Blobs">Blobs<a class="anchor-link" href="#Blobs"> </a></h3><p>First, a magic trick. Pick a filename, any filename. In an empty directory:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> <span class="nb">echo</span> sweet &gt; YOUR_FILENAME
 <span class="o">!</span> git init
 <span class="o">!</span> git add .
 <span class="o">!</span> find .git/objects -type f
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Reinitialized existing Git repository in /home/jovyan/work/git_magic/.git/
.git/objects/cc/d42c04c6d2eaae3fac6cca5caa0d49cd652b00
.git/objects/aa/823728ea7d592acc69b36875a482cdf3fd5c8d
.git/objects/cd/4bfa9f665f5a0861819a44f185f756ab204e0c
.git/objects/3f/866f780d4825a4e988d1858b756c9a9fa1a1d5
.git/objects/fb/68294b9c4c320e0fe123468270685e0739106e
.git/objects/ea/1a172cec8bb860e00fd6ecef20b9fc74c22425
.git/objects/38/0d73c9a0ad8af88ce229ddc6650309279b7fd0
.git/objects/22/64667f36f13659115f78653aac8c794fb2ef9c
.git/objects/83/f1f205dd8f99cb4d6eb0c96a4ec08c8c79c0bd
.git/objects/13/665904bc82a16cbf25145d2922d27c48819140
.git/objects/b7/e933d6338cf5af1058e623cecc9d1632ff1e98
.git/objects/da/087b57f5f5e0092f09c5dd766be607a3a6f590
.git/objects/93/8417075f4fe848cdddf9a851c37e6928ddafe7
.git/objects/ce/1439a5247efa53eee60aa8b19fb23b7595451a
.git/objects/ce/4223551fc20c995b0a29c4dc9c17c8a836dfb6
.git/objects/2f/4c48275b4ccc743b41239a4836a0f30e987359
.git/objects/9d/6ba467a42f3b11bd7134d51fb1e44e237945ae
.git/objects/b5/52733e393bda9b78ea87b63c4b6d83f9f8b889
.git/objects/66/f4c0e61ae134ac842727a5ee3a4589e95d880e
.git/objects/6e/0514175ec426316ebe37b3e3e3012df175629e
.git/objects/37/4bec6f6afb78fbbddf25d9769b9bee7e4502a3
.git/objects/a2/22463b723e20399eac204692307b9c4d18626b
.git/objects/10/b37faec2a416f7956060a180635a15a73e946f
.git/objects/87/778c93bc63ec19eb9a0f87236e17d13ccff823
.git/objects/1b/3ae68755525a5cbbdd7918726ec3ef919ea218
.git/objects/a8/284af8ae234ca1c440b1a1dcaa8afe1c638be1
.git/objects/pack/pack-699929489b78c4efc580016458df099eef31b039.pack
.git/objects/pack/pack-699929489b78c4efc580016458df099eef31b039.idx
.git/objects/d3/34045d44396934df4b7e9fd9a86af4107af1bf
.git/objects/98/2fb6cf7ad792b0c30a1b38efadb4d3113e3ab7
.git/objects/79/2717bfba11c2ee72c9ed584e8fde7eaade34f6
.git/objects/19/b45913521bdecf5e86ed3b03433b6c0a60b8e2
.git/objects/f7/074dc234590973d078ab072296499337bb6e53
.git/objects/96/9f7ae1ebe0a948ee76f9caf344e621743990c6
.git/objects/30/1f5517c154b8ed6a2ef4ce4ab993d336b8f352
.git/objects/85/a7bd8c251633b5afa7ec20951db8ab2e619822
.git/objects/26/3a6a293014cbc6249f350d3cbd025e014c8df2
.git/objects/5c/ce0def5318d97815add1e90d936045eab7b3bf
.git/objects/5c/b23049de6218255f9a083058018f3fed120852
.git/objects/0a/0696fcb373eb4db4bdc80048d01ef5755b5123
.git/objects/94/5aebb07d9b3e6895819cf3b986bc39ae0f0174
.git/objects/55/ac10e916d220eae459556e3342c4206b55a595
.git/objects/12/ad7c0952e6457870fd78249858f0076517dbfd
.git/objects/12/8c1628f2975af7c6ca44f5a39bf5d5ac6afc20
.git/objects/1a/3698e6153e4fcfffa5dc56cab6d512d47ea31f
.git/objects/3c/849204a6bf3914e17c215e8daa01cad4cfdf30
.git/objects/3c/5aad7bd149f00baadf8aaa64a362db30edbc97
.git/objects/29/7fb419c2f20602560d2a46cf33cca923fff035
.git/objects/7f/a969eb9478c4a30957922283afca82c7f3aea1
.git/objects/f1/02a9cadfa89ce554b3b26d2b90bfba2e05273c
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You'll see +.git/objects/aa/823728ea7d592acc69b36875a482cdf3fd5c8d+.</p>
<p>How do I know this without knowing the filename? It's because the
SHA1 hash of:</p>
<p>"blob" SP "6" NUL "sweet" LF</p>
<p>is aa823728ea7d592acc69b36875a482cdf3fd5c8d,
where SP is a space, NUL is a zero byte and LF is a linefeed. You can verify
this by typing:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span>  <span class="o">!</span> <span class="nb">printf</span> <span class="s2">&quot;blob 6\000sweet\n&quot;</span> <span class="p">|</span> sha1sum
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>aa823728ea7d592acc69b36875a482cdf3fd5c8d  -
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Git is 'content-addressable': files are not stored according to their filename,
but rather by the hash of the data they contain, in a file we call a 'blob
object'. We can think of the hash as a unique ID for a file's contents, so
in a sense we are addressing files by their content. The initial <code>blob 6</code> is
merely a header consisting of the object type and its length in bytes; it
simplifies internal bookkeeping.</p>
<p>Thus I could easily predict what you would see. The file's name is irrelevant:
only the data inside is used to construct the blob object.</p>
<p>You may be wondering what happens to identical files. Try adding copies of
your file, with any filenames whatsoever. The contents of +.git/objects+ stay
the same no matter how many you add. Git only stores the data once.</p>
<p>By the way, the files within +.git/objects+ are compressed with zlib so you
should not stare at them directly. Filter them through
<a href="http://www.zlib.net/zpipe.c[zpipe">http://www.zlib.net/zpipe.c[zpipe</a> -d], or type:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git cat-file -p aa823728ea7d592acc69b36875a482cdf3fd5c8d
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>sweet
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>which pretty-prints the given object.</p>
<h3 id="Trees">Trees<a class="anchor-link" href="#Trees"> </a></h3><p>But where are the filenames? They must be stored somewhere at some stage.
Git gets around to the filenames during a commit:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#  ! find .git/objects -type f</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You should now see 3 objects. This time I cannot tell you what the 2 new files are, as it partly depends on the filename you picked. We'll proceed assuming you chose ``rose''. If you didn't, you can rewrite history to make it look like you did:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#  ! find .git/objects -type f</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now you should see the file
+.git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9+, because this is the
SHA1 hash of its contents:</p>
<p>"tree" SP "32" NUL "100644 rose" NUL 0xaa823728ea7d592acc69b36875a482cdf3fd5c8d</p>
<p>Check this file does indeed contain the above by typing:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With zpipe, it's easy to verify the hash:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> zpipe -d &lt; .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9 <span class="p">|</span> sha1sum
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>/bin/bash: .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9: No such file or directory
da39a3ee5e6b4b0d3255bfef95601890afd80709  -
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Hash verification is trickier via cat-file because its output contains more
than the raw uncompressed object file.</p>
<p>This file is a 'tree' object: a list of tuples consisting of a file
type, a filename, and a hash. In our example, the file type is 100644, which
means <code>rose</code> is a normal file, and the hash is the blob object that contains
the contents of `rose'. Other possible file types are executables, symlinks or
directories. In the last case, the hash points to a tree object.</p>
<p>If you ran filter-branch, you'll have old objects you no longer need. Although
they will be jettisoned automatically once the grace period expires, we'll
delete them now to make our toy example easier to follow:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#  ! git reflog expire --expire=now --all</span>
<span class="c1">#  ! git prune</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For real projects you should typically avoid commands like this, as you are
destroying backups. If you want a clean repository, it is usually best to make
a fresh clone. Also, take care when directly manipulating +.git+: what if a Git
command is running at the same time, or a sudden power outage occurs?
In general, refs should be deleted with <em>git update-ref -d</em>,
though usually it's safe to remove +refs/original+ by hand.</p>
<h3 id="Commits">Commits<a class="anchor-link" href="#Commits"> </a></h3><p>We've explained 2 of the 3 objects. The third is a 'commit' object. Its
contents depend on the commit message as well as the date and time it was
created. To match what we have here, we'll have to tweak it a little:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#  ! git filter-branch --env-filter &#39;export</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">

<pre><code> GIT_AUTHOR_DATE="Fri 13 Feb 2009 15:31:30 -0800"
 GIT_AUTHOR_NAME="Alice"
 GIT_AUTHOR_EMAIL="alice@example.com"
 GIT_COMMITTER_DATE="Fri, 13 Feb 2009 15:31:30 -0800"
 GIT_COMMITTER_NAME="Bob"
 GIT_COMMITTER_EMAIL="bob@example.com"'  # Rig timestamps and authors.</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You should now see
+.git/objects/49/993fe130c4b3bf24857a15d7969c396b7bc187+
which is the SHA1 hash of its contents:</p>
<p>"commit 158" NUL
 "tree 05b217bb859794d08bb9e4f7f04cbda4b207fbe9" LF
 "author Alice <a href="mailto:alice@example.com">alice@example.com</a> 1234567890 -0800" LF
 "committer Bob <a href="mailto:bob@example.com">bob@example.com</a> 1234567890 -0800" LF
 LF
 "Shakespeare" LF</p>
<p>As before, you can run zpipe or cat-file to see for yourself.</p>
<p>This is the first commit, so there are no parent commits, but later commits
will always contain at least one line identifying a parent commit.</p>
<h3 id="Indistinguishable-From-Magic">Indistinguishable From Magic<a class="anchor-link" href="#Indistinguishable-From-Magic"> </a></h3><p>Git's secrets seem too simple. It looks like you could mix together a few shell scripts and add a dash of C code to cook it up in a matter of hours: a melange of basic filesystem operations and SHA1 hashing, garnished with lock files and fsyncs for robustness. In fact, this accurately describes the earliest versions of Git. Nonetheless, apart from ingenious packing tricks to save space, and ingenious indexing tricks to save time, we now know how Git deftly changes a filesystem into a database perfect for version control.</p>
<p>For example, if any file within the object database is corrupted by a disk
error, then its hash will no longer match, alerting us to the problem. By
hashing hashes of other objects, we maintain integrity at all levels. Commits
are atomic, that is, a commit can never only partially record changes: we can
only compute the hash of a commit and store it in the database after we already
have stored all relevant trees, blobs and parent commits. The object
database is immune to unexpected interruptions such as power outages.</p>
<p>We defeat even the most devious adversaries. Suppose somebody attempts to
stealthily modify the contents of a file in an ancient version of a project. To
keep the object database looking healthy, they must also change the hash of the
corresponding blob object since it's now a different string of bytes. This
means they'll have to change the hash of any tree object referencing the file,
and in turn change the hash of all commit objects involving such a tree, in
addition to the hashes of all the descendants of these commits. This implies the
hash of the official head differs to that of the bad repository. By
following the trail of mismatching hashes we can pinpoint the mutilated file,
as well as the commit where it was first corrupted.</p>
<p>In short, so long as the 20 bytes representing the last commit are safe,
it's impossible to tamper with a Git repository.</p>
<p>What about Git's famous features? Branching? Merging? Tags?
Mere details. The current head is kept in the file +.git/HEAD+,
which contains a hash of a commit object. The hash gets updated during a commit
as well as many other commands. Branches are almost the same: they are files in
+.git/refs/heads+. Tags too: they live in +.git/refs/tags+ but they
are updated by a different set of commands.</p>

</div>
</div>
</div>
</div>
 

