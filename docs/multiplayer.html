---

title: Multiplayer Git 

keywords: fastai
sidebar: home_sidebar

summary: "Summary"
description: "Summary"
nb_path: "06_multiplayer.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 06_multiplayer.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Initially I used Git on a private project where I was the sole developer.
Amongst the commands related to Git's distributed nature, I needed only <em>pull</em>
and <em>clone</em> so could I keep the same project in different places.</p>
<p>Later I wanted to publish my code with Git, and include changes from
contributors. I had to learn how to manage projects with multiple developers
from all over the world. Fortunately, this is Git's forte, and arguably its
raison d'Ãªtre.</p>
<h3 id="Who-Am-I?">Who Am I?<a class="anchor-link" href="#Who-Am-I?"> </a></h3><p>Every commit has an author name and email, which is shown by <em>git log</em>.
By default, Git uses system settings to populate these fields.
To set them explicitly, type:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span>  <span class="o">!</span> git config --global user.name <span class="s2">&quot;John Doe&quot;</span>
  <span class="o">!</span> git config --global user.email johndoe@example.com
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Omit the global flag to set these options only for the current repository.</p>
<h3 id="Git-Over-SSH,-HTTP">Git Over SSH, HTTP<a class="anchor-link" href="#Git-Over-SSH,-HTTP"> </a></h3><p>Suppose you have SSH access to a web server, but Git is not installed. Though
less efficient than its native protocol, Git can communicate over HTTP.</p>
<p>Download, compile and install Git in your account, and create a repository in
your web directory:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> <span class="nv">GIT_DIR</span><span class="o">=</span>proj.git git init
 <span class="o">!</span> <span class="nb">cd</span> proj.git
 <span class="o">!</span> git --bare update-server-info
 <span class="o">!</span> cp hooks/post-update.sample hooks/post-update
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For older versions of Git, the copy command fails and you should run:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> chmod a+x hooks/post-update
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now you can publish your latest edits via SSH from any clone:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git push web.server:/path/to/proj.git master
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>and anybody can get your project with:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git clone http://web.server/proj.git
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Git-Over-Anything">Git Over Anything<a class="anchor-link" href="#Git-Over-Anything"> </a></h3><p>Want to synchronize repositories without servers, or even a network connection?
Need to improvise during an emergency? We've seen &lt;&lt;makinghistory, <em>git
fast-export</em> and <em>git fast-import</em> can convert repositories to a single file
and back&gt;&gt;. We could shuttle such files back and forth to transport git
repositories over any medium, but a more efficient tool is <em>git bundle</em>.</p>
<p>The sender creates a 'bundle':</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git bundle create somefile HEAD
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>then transports the bundle, +somefile+, to the other party somehow: email,
thumb drive, an <em>xxd</em> printout and an OCR scanner, reading bits over the phone,
smoke signals, etc. The receiver retrieves commits from the bundle by typing:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git pull somefile
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The receiver can even do this from an empty repository. Despite its
size, +somefile+ contains the entire original git repository.</p>
<p>In larger projects, eliminate waste by bundling only changes the other
repository lacks. For example, suppose the commit ``1b6d...'' is the most
recent commit shared by both parties:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git bundle create somefile HEAD ^1b6d
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If done frequently, one could easily forget which commit was last sent. The
help page suggests using tags to solve this. Namely, after you send a bundle,
type:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git tag -f lastbundle HEAD
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>and create new refresher bundles with:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git bundle create newbundle HEAD ^lastbundle
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Patches:-The-Global-Currency">Patches: The Global Currency<a class="anchor-link" href="#Patches:-The-Global-Currency"> </a></h3><p>Patches are text representations of your changes that can be easily understood
by computers and humans alike. This gives them universal appeal. You can email a
patch to developers no matter what version control system they're using. As long
as your audience can read their email, they can see your edits. Similarly, on
your side, all you require is an email account: there's no need to setup an online Git repository.</p>
<p>Recall from the first chapter:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git diff 1b6d &gt; my.patch
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>outputs a patch which can be pasted into an email for discussion. In a Git
repository, type:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git apply &lt; my.patch
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>to apply the patch.</p>
<p>In more formal settings, when author names and perhaps signatures should be
recorded, generate the corresponding patches past a certain point by typing:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git format-patch 1b6d
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The resulting files can be given to <em>git-send-email</em>, or sent by hand. You can also specify a range of commits:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git format-patch 1b6d..HEAD^^
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On the receiving end, save an email to a file, then type:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git am &lt; email.txt
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This applies the incoming patch and also creates a commit, including information such as the author.</p>
<p>With a browser email client, you may need to click a button to see the email in its raw original form before saving the patch to a file.</p>
<p>There are slight differences for mbox-based email clients, but if you use one
of these, you're probably the sort of person who can figure them out easily
without reading tutorials!</p>
<h3 id="Sorry,-We've-Moved">Sorry, We've Moved<a class="anchor-link" href="#Sorry,-We've-Moved"> </a></h3><p>After cloning a repository, running <em>git push</em> or <em>git pull</em> will automatically
push to or pull from the original URL. How does Git do this? The secret lies in
config options created with the clone. Let's take a peek:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git config --list
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The +remote.origin.url+ option controls the source URL; <code>origin'' is a nickname
given to the source repository. As with the</code>master'' branch convention, we may
change or delete this nickname but there is usually no reason for doing so.</p>
<p>If the original repository moves, we can update the URL via:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git config remote.origin.url git://new.url/proj.git
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The +branch.master.merge+ option specifies the default remote branch in
a <em>git pull</em>. During the initial clone, it is set to the current branch of the
source repository, so even if the HEAD of the source repository subsequently
moves to a different branch, a later pull will faithfully follow the
original branch.</p>
<p>This option only applies to the repository we first cloned from, which is
recorded in the option +branch.master.remote+. If we pull in from other
repositories we must explicitly state which branch we want:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git pull git://example.com/other.git master
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The above explains why some of our earlier push and pull examples had no
arguments.</p>
<h3 id="Remote-Branches">Remote Branches<a class="anchor-link" href="#Remote-Branches"> </a></h3><p>When you clone a repository, you also clone all its branches. You may not have
noticed this because Git hides them away: you must ask for them specifically.
This prevents branches in the remote repository from interfering with
your branches, and also makes Git easier for beginners.</p>
<p>List the remote branches with:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git branch -r
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You should see something like:</p>
<p>origin/HEAD
 origin/master
 origin/experimental</p>
<p>These represent branches and the HEAD of the remote repository, and can be used
in regular Git commands. For example, suppose you have made many commits, and
wish to compare against the last fetched version. You could search through the
logs for the appropriate SHA1 hash, but it's much easier to type:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git diff origin/HEAD
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Or you can see what the ``experimental'' branch has been up to:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git log origin/experimental
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Multiple-Remotes">Multiple Remotes<a class="anchor-link" href="#Multiple-Remotes"> </a></h3><p>Suppose two other developers are working on our project, and we want to
keep tabs on both. We can follow more than one repository at a time with:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git remote add other git://example.com/some_repo.git
 <span class="o">!</span> git pull other some_branch
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we have merged in a branch from the second repository, and we have
easy access to all branches of all repositories:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git diff origin/experimental^ other/some_branch~5
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>But what if we just want to compare their changes without affecting our own
work? In other words, we want to examine their branches without having
their changes invade our working directory. Then rather than pull, run:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> <span class="o">!</span> git fetch        # Fetch from origin, the default.
 <span class="o">!</span> git fetch other  # Fetch from the second programmer.
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This just fetches histories. Although the working directory remains untouched,
we can refer to any branch of any repository in a Git command because we now
possess a local copy.</p>
<p>Recall that behind the scenes, a pull is simply a <em>fetch</em> then <em>merge</em>.
Usually we <em>pull</em> because we want to merge the latest commit after a fetch;
this situation is a notable exception.</p>
<p>See <em>git help remote</em> for how to remove remote repositories, ignore certain
branches, and more.</p>
<h3 id="My-Preferences">My Preferences<a class="anchor-link" href="#My-Preferences"> </a></h3><p>For my projects, I like contributors to prepare repositories from which I can
pull. Some Git hosting services let you host your own fork of a project with
the click of a button.</p>
<p>After I fetch a tree, I run Git commands to navigate and examine the changes,
which ideally are well-organized and well-described. I merge my own changes,
and perhaps make further edits. Once satisfied, I push to the main repository.</p>
<p>Though I infrequently receive contributions, I believe this approach scales
well. See
<a href="http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html[this">http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html[this</a>
blog post by Linus Torvalds].</p>
<p>Staying in the Git world is slightly more convenient than patch files, as it
saves me from converting them to Git commits. Furthermore, Git handles details
such as recording the author's name and email address, as well as the time and
date, and asks the author to describe their own change.</p>

</div>
</div>
</div>
</div>
 

